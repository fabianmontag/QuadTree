var N=Object.defineProperty;var C=(n,t,e)=>t in n?N(n,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):n[t]=e;var a=(n,t,e)=>(C(n,typeof t!="symbol"?t+"":t,e),e);(function(){const t=document.createElement("link").relList;if(t&&t.supports&&t.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))s(i);new MutationObserver(i=>{for(const o of i)if(o.type==="childList")for(const h of o.addedNodes)h.tagName==="LINK"&&h.rel==="modulepreload"&&s(h)}).observe(document,{childList:!0,subtree:!0});function e(i){const o={};return i.integrity&&(o.integrity=i.integrity),i.referrerPolicy&&(o.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?o.credentials="include":i.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function s(i){if(i.ep)return;i.ep=!0;const o=e(i);fetch(i.href,o)}})();const b=document.createElement("canvas");document.body.appendChild(b);const r=b.getContext("2d");r.canvas.width=window.innerWidth;r.canvas.height=window.innerHeight;const p=(n,t)=>(n=Math.ceil(n),t=Math.floor(t),Math.floor(Math.random()*(t-n+1)+n)),P=(n,t)=>({x:n??0,y:t??0}),R=(n,t="red")=>{r.save(),r.beginPath(),r.fillStyle=t,r.arc(n.x,n.y,5,0,2*Math.PI,!1),r.closePath(),r.fill(),r.restore()},I=(n,t,e="orange")=>{r.save(),r.beginPath(),r.fillStyle=e,r.globalAlpha=.5,r.arc(n.x,n.y,t,0,2*Math.PI,!1),r.closePath(),r.fill(),r.restore()},M=(n,t,e,s,i,o,h,l)=>{let u=e<i,c=n>h,y=t>l,g=s<o;return!(u||c||y||g)};class d{constructor(t,e,s,i){a(this,"x1");a(this,"y1");a(this,"x2");a(this,"y2");this.x1=t,this.y1=e,this.x2=s,this.y2=i}containsPoint(t){return t.x>=this.x1&&t.x<=this.x2&&t.y>=this.y1&&t.y<=this.y2}stroke(){const{x1:t,y1:e,x2:s,y2:i}=this;r.save(),r.beginPath(),r.strokeStyle="white",r.rect(t,e,s-t,i-e),r.closePath(),r.stroke(),r.restore()}fillOpaque(){const{x1:t,y1:e,x2:s,y2:i}=this;r.save(),r.beginPath(),r.fillStyle="white",r.globalAlpha=.4,r.rect(t,e,s-t,i-e),r.closePath(),r.fill(),r.restore()}intersectsWithRect(t){return M(this.x1,this.y1,this.x2,this.y2,t.x1,t.y1,t.x2,t.y2)}intersectsWithCircle(t,e,s){return O(this,t,e,s)}}function O(n,t,e,s){const{x1:i,y1:o,x2:h,y2:l}=n,u=P(i+(h-i)/2,o+(l-o)/2),c=h-i,y=l-o;var g=Math.abs(t-u.x),w=Math.abs(e-u.y);if(g>c/2+s||w>y/2+s)return!1;if(g<=c/2||w<=y/2)return!0;var Q=g-c/2,m=w-y/2;return Q*Q+m*m<=s*s}const W=(n,t,e,s,i)=>(s-n)*(s-n)+(i-t)*(i-t)<=e*e;class f{constructor(t){a(this,"boundary");a(this,"split");a(this,"topLeftQuad");a(this,"topRightQuad");a(this,"bottomLeftQuad");a(this,"bottomRightQuad");a(this,"points");a(this,"capacity");this.boundary=t,this.split=!1,this.points=[],this.capacity=1}splitIntoQuads(){const{x1:t,y1:e,x2:s,y2:i}=this.boundary,o=P(t+(s-t)/2,e+(i-e)/2),h=new f(new d(t,e,o.x,o.y));this.topLeftQuad=h;const l=new f(new d(o.x,e,s,o.y));this.topRightQuad=l;const u=new f(new d(t,o.y,o.x,i));this.bottomLeftQuad=u;const c=new f(new d(o.x,o.y,s,i));this.bottomRightQuad=c,this.split=!0}insertPoint(t){var e,s,i,o;this.boundary.containsPoint(t)&&(this.points.length<this.capacity?this.points.push(t):(this.split||this.splitIntoQuads(),(e=this.topLeftQuad)!=null&&e.boundary.containsPoint(t)?this.topLeftQuad.insertPoint(t):(s=this.topRightQuad)!=null&&s.boundary.containsPoint(t)?this.topRightQuad.insertPoint(t):(i=this.bottomLeftQuad)!=null&&i.boundary.containsPoint(t)?this.bottomLeftQuad.insertPoint(t):(o=this.bottomRightQuad)!=null&&o.boundary.containsPoint(t)&&this.bottomRightQuad.insertPoint(t)))}draw(){var t,e,s,i;for(let o=0;o<this.points.length;o++)R(this.points[o]);this.boundary.stroke(),this.split&&((t=this.topLeftQuad)==null||t.draw(),(e=this.topRightQuad)==null||e.draw(),(s=this.bottomLeftQuad)==null||s.draw(),(i=this.bottomRightQuad)==null||i.draw())}getNearbyPoints(t,e){const s=new d(t.x-e,t.y-e,t.x+e,t.y+e),i=[];if(this.boundary.intersectsWithRect(s)){for(const o of this.points)s.containsPoint(o)&&i.push(o);this.split&&(i.push(...this.topLeftQuad.getNearbyPoints(t,e)),i.push(...this.topRightQuad.getNearbyPoints(t,e)),i.push(...this.bottomLeftQuad.getNearbyPoints(t,e)),i.push(...this.bottomRightQuad.getNearbyPoints(t,e)))}return i}getNearbyPointsCircleRadius(t,e){const s=[];if(this.boundary.intersectsWithCircle(t.x,t.y,e)){for(const i of this.points)W(t.x,t.y,e,i.x,i.y)&&s.push(i);this.split&&(s.push(...this.topLeftQuad.getNearbyPointsCircleRadius(t,e)),s.push(...this.topRightQuad.getNearbyPointsCircleRadius(t,e)),s.push(...this.bottomLeftQuad.getNearbyPointsCircleRadius(t,e)),s.push(...this.bottomRightQuad.getNearbyPointsCircleRadius(t,e)))}return s}}const x=new f(new d(0,0,b.width,b.height)),L=[];for(let n=0;n<1e3;n++)L.push(P(p(0,window.innerWidth),p(0,window.innerHeight)));L.forEach(n=>{x.insertPoint(n)});x.draw();const v=P(p(0,window.innerWidth),p(0,window.innerHeight)),B=x.getNearbyPointsCircleRadius(v,50);I(v,50,"white");B.forEach(n=>{R(n,"blue")});
